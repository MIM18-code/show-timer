<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Show Timer">
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230a0a0f' width='100' height='100' rx='20'/><text x='50' y='62' text-anchor='middle' fill='%2322c55e' font-size='50' font-family='system-ui' font-weight='700'>T</text></svg>">
<title>Show Timer</title>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1e1e2e;
    --border: #2a2a3e;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --green: #22c55e;
    --green-bg: rgba(34,197,94,0.12);
    --yellow: #eab308;
    --yellow-bg: rgba(234,179,8,0.12);
    --red: #ef4444;
    --red-bg: rgba(239,68,68,0.12);
    --blue: #3b82f6;
    --blue-bg: rgba(59,130,246,0.12);
    --purple: #a855f7;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100dvh;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* === LAYOUT === */
  .app {
    display: grid;
    grid-template-rows: auto 1fr;
    height: 100dvh;
  }

  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    gap: 12px;
  }

  .show-selector {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  .show-btn {
    padding: 8px 16px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--surface2);
    color: var(--text-dim);
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .show-btn.active {
    background: var(--blue-bg);
    border-color: var(--blue);
    color: var(--blue);
  }

  .total-clock {
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 14px;
    color: var(--text-dim);
    text-align: right;
    min-width: 180px;
  }

  .total-clock span { color: var(--text); font-weight: 600; }

  /* === MAIN CONTENT === */
  .main {
    display: grid;
    grid-template-columns: 1fr 280px;
    overflow: hidden;
  }

  /* === CENTER: TIMER === */
  .timer-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 12px;
  }

  .segment-label {
    font-size: 18px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
  }

  .segment-label .num {
    color: var(--blue);
  }

  .timer-display {
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: clamp(80px, 15vw, 140px);
    font-weight: 700;
    line-height: 1;
    letter-spacing: -2px;
    transition: color 0.3s;
  }

  .timer-display.on-time { color: var(--green); }
  .timer-display.warning { color: var(--yellow); }
  .timer-display.over { color: var(--red); }
  .timer-display.idle { color: var(--text-dim); }
  .timer-display.paused { opacity: 1; }
  .timer-display.paused-blink { opacity: 0.3; }

  .timer-sub {
    font-size: 16px;
    font-weight: 500;
    height: 24px;
  }

  .timer-sub.on-time { color: var(--green); }
  .timer-sub.warning { color: var(--yellow); }
  .timer-sub.over { color: var(--red); }

  /* Progress bar */
  .progress-container {
    width: 80%;
    max-width: 500px;
    height: 6px;
    background: var(--surface2);
    border-radius: 3px;
    overflow: visible;
    position: relative;
  }

  .progress-bar {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s linear, background 0.3s;
    max-width: 100%;
  }

  .progress-bar.on-time { background: var(--green); }
  .progress-bar.warning { background: var(--yellow); }
  .progress-bar.over { background: var(--red); }

  /* === CONTROLS === */
  .controls {
    display: flex;
    gap: 12px;
    margin-top: 8px;
    flex-wrap: wrap;
  }

  .ctrl-btn {
    padding: 14px 28px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: var(--surface2);
    color: var(--text);
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    min-width: 90px;
    min-height: 48px;
  }

  .ctrl-btn:active { transform: scale(0.96); }

  .ctrl-btn.primary {
    background: var(--green);
    border-color: var(--green);
    color: #000;
  }

  .ctrl-btn.primary.pause {
    background: var(--yellow);
    border-color: var(--yellow);
  }

  .ctrl-btn.danger {
    border-color: var(--red);
    color: var(--red);
  }

  .ctrl-btn:disabled {
    opacity: 0.3;
    pointer-events: none;
  }

  /* === QUICK ADJUST === */
  .adjust-row {
    display: flex;
    gap: 8px;
    margin-top: 4px;
  }

  .adjust-btn {
    padding: 10px 18px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--surface2);
    color: var(--text-dim);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    font-family: 'SF Mono', 'Menlo', monospace;
    transition: all 0.15s;
    min-height: 44px;
    min-width: 60px;
  }

  .adjust-btn:active { transform: scale(0.95); background: var(--surface); }

  /* === SIDEBAR: SEGMENTS === */
  .sidebar {
    background: var(--surface);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    padding: 12px;
  }

  .sidebar-title {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-dim);
    margin-bottom: 10px;
    padding: 0 4px;
  }

  .drift-banner {
    font-size: 11px;
    font-weight: 600;
    padding: 6px 10px;
    border-radius: 6px;
    margin-bottom: 8px;
    text-align: center;
  }
  .drift-banner.drift-over {
    background: var(--red-bg);
    color: var(--red);
    border: 1px solid rgba(239,68,68,0.25);
  }
  .drift-banner.drift-under {
    background: var(--green-bg);
    color: var(--green);
    border: 1px solid rgba(34,197,94,0.25);
  }

  .seg-card {
    padding: 10px 12px;
    border-radius: 8px;
    margin-bottom: 6px;
    border: 1px solid transparent;
    transition: all 0.2s;
  }

  .seg-card.completed {
    background: var(--surface2);
    opacity: 0.6;
  }

  .seg-card.completed.editable { cursor: pointer; min-height: 44px; }
  .seg-card.completed.editable:hover,
  .seg-card.completed.editable:active { opacity: 0.85; border-color: var(--blue); }

  .seg-card.active {
    background: var(--blue-bg);
    border-color: var(--blue);
  }

  .seg-card.upcoming {
    background: var(--surface2);
  }

  .seg-card.intro-card {
    background: var(--surface2);
    border: 1px dashed var(--border);
    margin-top: 8px;
  }

  .seg-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2px;
  }

  .seg-name {
    font-size: 13px;
    font-weight: 600;
  }

  .seg-time {
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 13px;
    font-weight: 600;
  }

  .seg-detail {
    font-size: 11px;
    color: var(--text-dim);
  }

  .seg-detail .drift-over { color: var(--red); font-weight: 600; }
  .seg-detail .drift-under { color: var(--green); font-weight: 600; }
  .seg-detail .adjusted { color: var(--yellow); }

  /* === EDIT MODAL === */
  .edit-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .edit-overlay.visible { display: flex; }

  .edit-modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    min-width: 280px;
    text-align: center;
  }

  .edit-modal h3 {
    font-size: 16px;
    margin-bottom: 4px;
  }

  .edit-modal .edit-hint {
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 16px;
  }

  .edit-time-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-bottom: 16px;
  }

  .edit-time-inputs input {
    width: 70px;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--surface2);
    color: var(--text);
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 20px;
    font-weight: 600;
    text-align: center;
    -webkit-user-select: text;
    user-select: text;
  }

  .edit-time-inputs input:focus {
    outline: none;
    border-color: var(--blue);
  }

  .edit-time-inputs .separator {
    font-size: 24px;
    font-weight: 700;
    color: var(--text-dim);
  }

  .edit-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  /* === CONFIRM OVERLAY === */
  .confirm-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .confirm-overlay.visible { display: flex; }

  .confirm-modal {
    background: var(--surface);
    border: 1px solid var(--red);
    border-radius: 16px;
    padding: 24px;
    min-width: 280px;
    text-align: center;
  }

  .confirm-modal h3 {
    font-size: 18px;
    color: var(--red);
    margin-bottom: 8px;
  }

  .confirm-modal p {
    font-size: 14px;
    color: var(--text-dim);
    margin-bottom: 20px;
  }

  .confirm-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  /* === INTRO RESULT === */
  .intro-result {
    text-align: center;
    padding: 16px;
  }

  .intro-result .label {
    font-size: 14px;
    color: var(--text-dim);
    margin-bottom: 4px;
  }

  .intro-result .time {
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 28px;
    font-weight: 700;
  }

  /* === STATE: NOT STARTED === */
  .start-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
  }

  .start-screen h2 {
    font-size: 24px;
    font-weight: 700;
  }

  .start-screen p {
    color: var(--text-dim);
    font-size: 14px;
    text-align: center;
    max-width: 360px;
  }

  /* === SHOW COMPLETE OVERLAY === */
  .show-complete {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(10,10,15,0.95);
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    z-index: 10;
  }

  .show-complete.visible {
    display: flex;
  }

  .show-complete h2 {
    font-size: 28px;
    font-weight: 700;
  }

  /* === WAKE LOCK INDICATOR === */
  .wake-lock-indicator {
    font-size: 11px;
    color: var(--green);
    opacity: 0.6;
  }

  .wake-lock-indicator.off {
    color: var(--red);
  }

  /* Prevent Safari swipe-back gesture */
  html, body { overscroll-behavior: none; }

  /* Responsive */
  @media (max-width: 768px) {
    .main {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr auto;
    }
    .sidebar {
      border-left: none;
      border-top: 1px solid var(--border);
      max-height: 200px;
      display: flex;
      gap: 6px;
      padding: 8px;
      overflow-x: auto;
      overflow-y: hidden;
    }
    .sidebar-title { display: none; }
    .seg-card { min-width: 120px; margin-bottom: 0; }
    .seg-card.intro-card { margin-top: 0; }
    .timer-display { font-size: clamp(60px, 12vw, 100px); }
  }
</style>
</head>
<body>
<div class="app">
  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="show-selector" id="showSelector"></div>
    <div style="display:flex;align-items:center;gap:12px;">
      <span class="wake-lock-indicator off" id="wakeLockStatus" title="Screen wake lock"></span>
      <div class="total-clock" id="totalClock">
        Elapsed <span id="elapsed">00:00</span> &nbsp;/&nbsp; Target <span id="target">00:00</span>
      </div>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main" style="position:relative;">
    <!-- TIMER AREA -->
    <div class="timer-area" id="timerArea">
      <div class="start-screen" id="startScreen">
        <h2 id="showTitle">Select a Show</h2>
        <p>Choose a show above, then tap Start to begin timing Section 1. Segments auto-adjust to keep the final segment on time.</p>
        <button class="ctrl-btn primary" id="bigStartBtn" onclick="startShow()" style="padding:18px 48px;font-size:18px;">Start</button>
      </div>
      <div id="activeTimer" style="display:none;width:100%;text-align:center;">
        <div class="segment-label" id="segLabel">Section <span class="num">1</span></div>
        <div class="timer-display idle" id="timerDisplay">00:00</div>
        <div class="timer-sub" id="timerSub">&nbsp;</div>
        <div class="progress-container">
          <div class="progress-bar on-time" id="progressBar" style="width:0%"></div>
        </div>
        <div class="adjust-row" id="adjustRow" style="justify-content:center;">
          <button class="adjust-btn" onclick="adjustSegTime(-30)" title="I was 30s late hitting Next">-30s</button>
          <button class="adjust-btn" onclick="adjustSegTime(-10)" title="I was 10s late hitting Next">-10s</button>
          <button class="adjust-btn" onclick="adjustSegTime(+10)" title="Add 10s">+10s</button>
          <button class="adjust-btn" onclick="adjustSegTime(+30)" title="Add 30s">+30s</button>
        </div>
        <div class="controls" style="justify-content:center;margin-top:16px;">
          <button class="ctrl-btn" id="btnBack" onclick="prevSegment()" disabled>&larr; Back</button>
          <button class="ctrl-btn primary" id="btnStartPause" onclick="toggleStartPause()">Start</button>
          <button class="ctrl-btn" id="btnNext" onclick="nextSegment()">Next &rarr;</button>
          <button class="ctrl-btn danger" id="btnReset" onclick="confirmReset()">Reset</button>
        </div>
      </div>
    </div>

    <!-- SHOW COMPLETE -->
    <div class="show-complete" id="showComplete">
      <h2>All Segments Done</h2>
      <div style="margin-top:12px;font-size:14px;color:var(--text-dim);text-transform:uppercase;letter-spacing:2px;">Intro needs to be</div>
      <div class="time" id="introTime" style="font-family:'SF Mono','Menlo',monospace;font-size:clamp(80px,14vw,130px);font-weight:700;color:var(--green);line-height:1;">0:10</div>
      <div id="introTimerLive" style="display:none;">
        <div style="font-family:'SF Mono','Menlo',monospace;font-size:clamp(60px,10vw,100px);font-weight:700;line-height:1;" id="introCountdown">0:10</div>
        <div style="font-size:14px;margin-top:4px;color:var(--text-dim);" id="introCountdownSub"></div>
      </div>
      <div style="display:flex;gap:12px;margin-top:16px;" id="introControls">
        <button class="ctrl-btn primary" id="btnIntroStart" onclick="startIntroTimer()" style="padding:14px 32px;font-size:16px;">Time the Intro</button>
      </div>
      <div style="margin-top:16px;padding:12px 20px;background:var(--surface2);border-radius:10px;text-align:center;">
        <div style="font-size:12px;color:var(--text-dim);margin-bottom:4px;">Segments total</div>
        <div style="font-family:'SF Mono','Menlo',monospace;font-size:20px;font-weight:600;" id="totalActual">00:00</div>
        <div style="font-size:12px;color:var(--text-dim);margin-top:6px;" id="driftSummary"></div>
      </div>
      <button class="ctrl-btn danger" onclick="confirmReset()" style="margin-top:16px;">Reset Show</button>
    </div>

    <!-- SIDEBAR -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-title">Segments</div>
    </div>
  </div>
</div>

<!-- EDIT TIME MODAL -->
<div class="edit-overlay" id="editOverlay">
  <div class="edit-modal">
    <h3 id="editTitle">Edit Section 1</h3>
    <div class="edit-hint">Actual time for this segment</div>
    <div class="edit-time-inputs">
      <input type="number" id="editMin" min="0" max="99" placeholder="mm">
      <span class="separator">:</span>
      <input type="number" id="editSec" min="0" max="59" placeholder="ss">
    </div>
    <div class="edit-buttons">
      <button class="ctrl-btn" onclick="closeEditModal()">Cancel</button>
      <button class="ctrl-btn primary" onclick="saveEditModal()">Save</button>
    </div>
  </div>
</div>

<!-- RESET CONFIRM MODAL -->
<div class="confirm-overlay" id="confirmOverlay">
  <div class="confirm-modal">
    <h3>Reset Show?</h3>
    <p>All timing data will be lost. This cannot be undone.</p>
    <div class="confirm-buttons">
      <button class="ctrl-btn" onclick="closeConfirm()">Cancel</button>
      <button class="ctrl-btn danger" onclick="doReset()" style="background:var(--red-bg);">Yes, Reset</button>
    </div>
  </div>
</div>

<script>
// ===== SHOW DATA =====
const SHOWS = {
  touchdown: {
    name: "Touchdown Baltimore",
    introTarget: 10,
    segments: [
      { name: "Section 1", target: 8 * 60 },
      { name: "Section 2", target: 8 * 60 },
      { name: "Section 3", target: 7 * 60 + 40 },
      { name: "Section 4", target: 7 * 60 + 44 },
      { name: "Section 5", target: 8 * 60 },
      { name: "Section 6", target: 2 * 60 },
    ]
  },
  walltowall: {
    name: "Wall to Wall Baseball",
    introTarget: 10,
    segments: [
      { name: "Section 1", target: 7 * 60 + 30 },
      { name: "Section 2", target: 7 * 60 + 15 },
      { name: "Section 3", target: 7 * 60 + 15 },
      { name: "Section 4", target: 7 * 60 + 15 },
      { name: "Section 5", target: 7 * 60 + 15 },
      { name: "Section 6", target: 7 * 60 + 15 },
    ]
  },
  touchdown5: {
    name: "Touchdown (5min Close)",
    introTarget: 10,
    segments: [
      { name: "Section 1", target: 7 * 60 + 24 },
      { name: "Section 2", target: 7 * 60 + 24 },
      { name: "Section 3", target: 7 * 60 + 4 },
      { name: "Section 4", target: 7 * 60 + 8 },
      { name: "Section 5", target: 7 * 60 + 24 },
      { name: "Section 6", target: 5 * 60 },
    ]
  },
  ballgame: {
    name: "Take Me Out to the Ballgame",
    introTarget: 10,
    segments: [
      { name: "Section 1", target: 5 * 60 + 30 },
      { name: "Section 2", target: 6 * 60 },
      { name: "Section 3", target: 5 * 60 + 30 },
      { name: "Section 4", target: 2 * 60 + 7 },
    ]
  }
};

// ===== STATE =====
let currentShow = null;
let state = {
  phase: 'idle', // idle, running, paused, complete
  currentSeg: 0,
  segElapsed: 0,
  segActuals: [],
  showStartTime: null,
  segStartTime: null,
  pauseStartTime: null,
};

let timerInterval = null;
let blinkInterval = null;
let wakeLock = null;
let editingSegIndex = -1;

// ===== WAKE LOCK =====
async function requestWakeLock() {
  if (!('wakeLock' in navigator)) return;
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLock.addEventListener('release', () => {
      updateWakeLockUI(false);
    });
    updateWakeLockUI(true);
  } catch (e) {
    updateWakeLockUI(false);
  }
}

function releaseWakeLock() {
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
  }
  updateWakeLockUI(false);
}

function updateWakeLockUI(active) {
  const el = document.getElementById('wakeLockStatus');
  if (active) {
    el.textContent = 'SCREEN ON';
    el.className = 'wake-lock-indicator';
  } else {
    el.textContent = '';
    el.className = 'wake-lock-indicator off';
  }
}

// Re-acquire wake lock when tab becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && state.phase === 'running') {
    requestWakeLock();
  }
});

// ===== LOCAL STORAGE PERSISTENCE =====
const STORAGE_KEY = 'showTimerState';

function saveState() {
  try {
    const data = {
      currentShow,
      state: {
        phase: state.phase,
        currentSeg: state.currentSeg,
        segElapsed: state.segElapsed,
        segActuals: state.segActuals,
        // Store timestamps as offsets from now so we can restore relative timing
        segStartTimeOffset: state.segStartTime ? Date.now() - state.segStartTime : null,
        pauseStartTimeOffset: state.pauseStartTime ? Date.now() - state.pauseStartTime : null,
      },
      savedAt: Date.now(),
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  } catch (e) { /* storage full or unavailable */ }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);

    // Don't restore if saved more than 4 hours ago
    if (Date.now() - data.savedAt > 4 * 60 * 60 * 1000) {
      localStorage.removeItem(STORAGE_KEY);
      return false;
    }

    if (!SHOWS[data.currentShow]) return false;

    currentShow = data.currentShow;
    const s = data.state;

    state.phase = s.phase;
    state.currentSeg = s.currentSeg;
    state.segElapsed = s.segElapsed;
    state.segActuals = s.segActuals;
    state.segStartTime = s.segStartTimeOffset != null ? Date.now() - s.segStartTimeOffset : null;
    state.pauseStartTime = s.pauseStartTimeOffset != null ? Date.now() - s.pauseStartTimeOffset : null;

    return true;
  } catch (e) {
    return false;
  }
}

function clearSavedState() {
  localStorage.removeItem(STORAGE_KEY);
}

// ===== INIT =====
function init() {
  const sel = document.getElementById('showSelector');
  sel.innerHTML = '';
  for (const [key, show] of Object.entries(SHOWS)) {
    const btn = document.createElement('button');
    btn.className = 'show-btn' + (currentShow === key ? ' active' : '');
    btn.textContent = show.name;
    btn.onclick = () => selectShow(key);
    sel.appendChild(btn);
  }
  if (!currentShow) selectShow('touchdown');
}

function selectShow(key) {
  // Don't switch while running OR paused
  if (state.phase === 'running' || state.phase === 'paused') return;
  currentShow = key;
  resetShow();
  init();
}

function resetShow() {
  stopTimer();
  stopBlink();
  releaseWakeLock();
  state = {
    phase: 'idle',
    currentSeg: 0,
    segElapsed: 0,
    segActuals: [],
    showStartTime: null,
    segStartTime: null,
    pauseStartTime: null,
  };
  clearSavedState();
  document.getElementById('showComplete').classList.remove('visible');
  document.getElementById('startScreen').style.display = 'flex';
  document.getElementById('activeTimer').style.display = 'none';
  document.getElementById('showTitle').textContent = SHOWS[currentShow].name;
  updateSidebar();
  updateTotalClock();
  document.querySelectorAll('.show-btn').forEach(b => b.style.pointerEvents = '');
}

// ===== RESET CONFIRMATION =====
function confirmReset() {
  // If idle, no need to confirm
  if (state.phase === 'idle') { resetShow(); return; }
  document.getElementById('confirmOverlay').classList.add('visible');
}

function closeConfirm() {
  document.getElementById('confirmOverlay').classList.remove('visible');
}

function doReset() {
  closeConfirm();
  resetShow();
}

// ===== TIMER ENGINE =====
function startShow() {
  state.phase = 'running';
  state.showStartTime = Date.now();
  state.segStartTime = Date.now();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('activeTimer').style.display = '';
  document.querySelectorAll('.show-btn').forEach(b => b.style.pointerEvents = 'none');
  requestWakeLock();
  startTimer();
  updateUI();
}

function toggleStartPause() {
  if (state.phase === 'idle') {
    startShow();
    return;
  }
  if (state.phase === 'running') {
    // Pause
    state.phase = 'paused';
    state.pauseStartTime = Date.now();
    stopTimer();
    startBlink();
    saveState();
    updateUI();
  } else if (state.phase === 'paused') {
    // Resume: adjust segStartTime forward by pause duration
    const pausedDuration = Date.now() - state.pauseStartTime;
    state.segStartTime += pausedDuration;
    state.pauseStartTime = null;
    state.phase = 'running';
    stopBlink();
    requestWakeLock();
    startTimer();
    updateUI();
  }
}

function startTimer() {
  stopTimer();
  timerInterval = setInterval(tick, 100);
}

function stopTimer() {
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function startBlink() {
  stopBlink();
  let on = true;
  const el = document.getElementById('timerDisplay');
  blinkInterval = setInterval(() => {
    on = !on;
    el.classList.toggle('paused', on);
    el.classList.toggle('paused-blink', !on);
  }, 500);
}

function stopBlink() {
  if (blinkInterval) { clearInterval(blinkInterval); blinkInterval = null; }
  const el = document.getElementById('timerDisplay');
  el.classList.remove('paused', 'paused-blink');
}

function tick() {
  if (state.phase !== 'running') return;
  state.segElapsed = (Date.now() - state.segStartTime) / 1000;
  updateUI();

  // Periodic save (every 5 seconds)
  if (!tick._lastSave || Date.now() - tick._lastSave > 5000) {
    tick._lastSave = Date.now();
    saveState();
  }
}

// ===== SEGMENT NAVIGATION =====
function nextSegment() {
  if (state.phase === 'idle') return;
  // Block if waiting between segments (nothing running to end)
  if (state.phase === 'paused' && state.segElapsed < 0.5) return;
  const show = SHOWS[currentShow];
  state.segActuals.push(state.segElapsed);

  if (state.currentSeg >= show.segments.length - 1) {
    completeShow();
    return;
  }

  // Always pause between segments — operator starts next one when talent is ready
  stopTimer();
  stopBlink();

  state.currentSeg++;
  state.segStartTime = Date.now();
  state.segElapsed = 0;
  state.phase = 'paused';
  state.pauseStartTime = Date.now();

  startBlink();
  saveState();
  updateUI();
  updateSidebar();
}

function prevSegment() {
  if (state.currentSeg === 0) return;
  // Confirm if going back would discard a completed segment's time
  if (state.segActuals.length > 0) {
    const prevName = SHOWS[currentShow].segments[state.currentSeg - 1].name;
    const prevTime = formatTime(state.segActuals[state.segActuals.length - 1]);
    if (!confirm(`Go back to ${prevName}? This will discard the recorded time (${prevTime}) and restart it.`)) return;
  }
  stopTimer();
  stopBlink();

  state.segActuals.pop();
  state.currentSeg--;
  state.segStartTime = Date.now();
  state.segElapsed = 0;
  state.phase = 'paused';
  state.pauseStartTime = Date.now();

  saveState();
  updateUI();
  updateSidebar();
}

// ===== QUICK ADJUST =====
function adjustSegTime(deltaSec) {
  // Shift segStartTime to effectively add/remove elapsed time
  // Negative delta = "I was late, subtract time" = push segStartTime forward
  // Positive delta = "add more time" = push segStartTime backward
  state.segStartTime -= deltaSec * 1000;
  state.segElapsed = Math.max(0, state.segElapsed + deltaSec);
  // If adjusting makes elapsed negative, clamp segStartTime
  if (state.segElapsed <= 0) {
    state.segElapsed = 0;
    state.segStartTime = Date.now();
    if (state.phase === 'paused') {
      state.pauseStartTime = Date.now();
    }
  }
  saveState();
  updateUI();
  updateSidebar();
}

// ===== SHOW COMPLETE =====
function completeShow() {
  state.phase = 'complete';
  stopTimer();
  stopBlink();
  releaseWakeLock();

  const show = SHOWS[currentShow];
  const totalActualSegments = state.segActuals.reduce((s, t) => s + t, 0);
  const drift = totalActualSegments - show.segments.reduce((s, seg) => s + seg.target, 0);
  const introNeeded = show.introTarget - drift;

  document.getElementById('introTime').textContent = formatTime(Math.max(0, introNeeded));
  document.getElementById('introTime').style.color =
    introNeeded < 3 ? 'var(--red)' : introNeeded < 8 ? 'var(--yellow)' : 'var(--green)';

  // Reset intro timer display state
  document.getElementById('introTime').style.display = '';
  document.getElementById('introTimerLive').style.display = 'none';
  document.getElementById('btnIntroStart').textContent = 'Time the Intro';
  document.getElementById('btnIntroStart').setAttribute('onclick', 'startIntroTimer()');
  document.getElementById('btnIntroStart').className = 'ctrl-btn primary';

  document.getElementById('totalActual').textContent = formatTime(totalActualSegments);

  const driftText = drift > 0
    ? `Segments ran ${formatTime(drift)} over. Intro needs to be shorter.`
    : drift < 0
    ? `Segments ran ${formatTime(Math.abs(drift))} under. Intro can be longer.`
    : `Segments hit target exactly.`;
  document.getElementById('driftSummary').textContent = driftText;

  document.getElementById('showComplete').classList.add('visible');
  document.querySelectorAll('.show-btn').forEach(b => b.style.pointerEvents = '');
  saveState();
  updateSidebar();
}

// Recalculate the complete screen (called after editing a segment time)
function recalcComplete() {
  if (state.phase !== 'complete') return;
  const show = SHOWS[currentShow];
  const totalActualSegments = state.segActuals.reduce((s, t) => s + t, 0);
  const drift = totalActualSegments - show.segments.reduce((s, seg) => s + seg.target, 0);
  const introNeeded = show.introTarget - drift;

  document.getElementById('introTime').textContent = formatTime(Math.max(0, introNeeded));
  document.getElementById('introTime').style.color =
    introNeeded < 3 ? 'var(--red)' : introNeeded < 8 ? 'var(--yellow)' : 'var(--green)';

  document.getElementById('totalActual').textContent = formatTime(totalActualSegments);

  const driftText = drift > 0
    ? `Segments ran ${formatTime(drift)} over. Intro needs to be shorter.`
    : drift < 0
    ? `Segments ran ${formatTime(Math.abs(drift))} under. Intro can be longer.`
    : `Segments hit target exactly.`;
  document.getElementById('driftSummary').textContent = driftText;
}

// ===== EDIT SEGMENT TIME =====
function openEditModal(segIndex) {
  editingSegIndex = segIndex;
  const show = SHOWS[currentShow];
  const actual = state.segActuals[segIndex];
  document.getElementById('editTitle').textContent = `Edit ${show.segments[segIndex].name}`;
  document.getElementById('editMin').value = Math.floor(actual / 60);
  document.getElementById('editSec').value = Math.floor(actual % 60);
  document.getElementById('editOverlay').classList.add('visible');
  document.getElementById('editMin').focus();
  document.getElementById('editMin').select();
}

function closeEditModal() {
  document.getElementById('editOverlay').classList.remove('visible');
  editingSegIndex = -1;
}

function saveEditModal() {
  if (editingSegIndex < 0) return;
  const m = Math.max(0, parseInt(document.getElementById('editMin').value) || 0);
  const s = Math.min(59, Math.max(0, parseInt(document.getElementById('editSec').value) || 0));
  const newTime = m * 60 + s;
  state.segActuals[editingSegIndex] = newTime;
  closeEditModal();
  saveState();
  updateSidebar();
  updateTotalClock();
  recalcComplete();
}

// ===== DRIFT / ADJUSTMENT CALCULATION =====
function getAdjustedTargets() {
  const show = SHOWS[currentShow];
  const targets = show.segments.map(s => s.target);
  const n = targets.length;
  const adjusted = [...targets];

  // Step 1: Drift from COMPLETED segments only
  let completedDrift = 0;
  for (let i = 0; i < state.segActuals.length; i++) {
    completedDrift += state.segActuals[i] - targets[i];
  }

  const curIdx = state.segActuals.length; // current or next-to-run segment
  if (curIdx >= n) return adjusted; // all segments done

  // Step 2: Adjust current + future based on completed drift
  const remainingFromCurrent = n - curIdx;
  if (completedDrift !== 0) {
    if (Math.abs(completedDrift) <= 90) {
      // Small drift: absorb into current segment's target
      adjusted[curIdx] = Math.max(30, targets[curIdx] - completedDrift);
    } else {
      // Large drift: spread evenly across current + future
      const perSeg = completedDrift / remainingFromCurrent;
      for (let i = curIdx; i < n; i++) {
        adjusted[i] = Math.max(30, targets[i] - perSeg);
      }
    }
  }

  // Step 3: If current segment is RUNNING and over its adjusted target,
  // redistribute that overflow to FUTURE segments only.
  // (Current segment's own display uses the Step 2 target — no double-count.)
  const futureStart = curIdx + 1;
  const futureCount = n - futureStart;

  if (futureCount > 0 && (state.phase === 'running' || state.phase === 'paused')) {
    const liveOver = state.segElapsed - adjusted[curIdx];
    if (liveOver > 0) {
      if (liveOver <= 90) {
        // Small overflow: dump on next future segment
        adjusted[futureStart] = Math.max(30, adjusted[futureStart] - liveOver);
      } else {
        // Large overflow: spread across all future segments
        const perSeg = liveOver / futureCount;
        for (let i = futureStart; i < n; i++) {
          adjusted[i] = Math.max(30, adjusted[i] - perSeg);
        }
      }
    }
  }

  return adjusted;
}

// ===== UI UPDATES =====
function updateUI() {
  const show = SHOWS[currentShow];
  const seg = show.segments[state.currentSeg];
  const adjusted = getAdjustedTargets();
  const segTarget = state.currentSeg < state.segActuals.length
    ? show.segments[state.currentSeg].target
    : adjusted[state.currentSeg];

  document.getElementById('segLabel').innerHTML =
    `${seg.name.replace(/(\d+)/, '<span class="num">$1</span>')}`;

  const remaining = segTarget - state.segElapsed;
  const display = document.getElementById('timerDisplay');
  const sub = document.getElementById('timerSub');

  const newTime = remaining >= 0 ? formatTime(remaining) : '-' + formatTime(Math.abs(remaining));
  const newState = remaining < 0 ? 'over' : remaining <= 30 ? 'warning' : 'on-time';

  if (display.textContent !== newTime) display.textContent = newTime;

  const newClass = 'timer-display ' + newState;
  if (display.className !== newClass) display.className = newClass;

  let newSub, newSubClass;
  if (remaining >= 0 && remaining <= 30) {
    newSub = 'Wrapping up...';
    newSubClass = 'timer-sub warning';
  } else if (remaining >= 0) {
    newSub = `${formatTime(segTarget)} target`;
    newSubClass = 'timer-sub on-time';
  } else {
    newSub = `OVER by ${formatTime(Math.abs(remaining))}`;
    newSubClass = 'timer-sub over';
  }
  if (sub.textContent !== newSub) sub.textContent = newSub;
  if (sub.className !== newSubClass) sub.className = newSubClass;

  const pct = Math.min(100, (state.segElapsed / segTarget) * 100);
  const bar = document.getElementById('progressBar');
  bar.style.width = pct + '%';
  const barClass = 'progress-bar ' + newState;
  if (bar.className !== barClass) bar.className = barClass;

  const btnSP = document.getElementById('btnStartPause');
  const btnNext = document.getElementById('btnNext');
  const isWaiting = state.phase === 'paused' && state.segElapsed < 0.5;
  const isFinalSeg = state.currentSeg >= show.segments.length - 1;

  const adjustRow = document.getElementById('adjustRow');

  // Reset inline styles that waiting state sets
  btnSP.style.padding = '';
  btnSP.style.fontSize = '';

  if (state.phase === 'running') {
    btnSP.textContent = 'Pause';
    btnSP.className = 'ctrl-btn primary pause';
    btnNext.textContent = isFinalSeg ? 'End Final' : 'End Segment';
    btnNext.className = 'ctrl-btn danger';
    btnNext.style.display = '';
    adjustRow.style.display = 'flex';
  } else if (isWaiting) {
    // Between segments: clearly different from mid-segment pause
    stopBlink();
    const nextName = show.segments[state.currentSeg].name;
    btnSP.textContent = `Start ${nextName}`;
    btnSP.className = 'ctrl-btn primary';
    btnSP.style.padding = '18px 40px';
    btnSP.style.fontSize = '17px';
    // Static display — no blink, show target for next segment
    display.textContent = formatTime(segTarget);
    display.className = 'timer-display idle';
    sub.textContent = `Ready \u2014 ${nextName}`;
    sub.className = 'timer-sub';
    bar.style.width = '0%';
    // Hide End Segment button and adjust when waiting — nothing to end or adjust
    btnNext.style.display = 'none';
    adjustRow.style.display = 'none';
  } else if (state.phase === 'paused') {
    // Paused mid-segment
    btnSP.textContent = 'Resume';
    btnSP.className = 'ctrl-btn primary';
    btnNext.textContent = isFinalSeg ? 'End Final' : 'End Segment';
    btnNext.className = 'ctrl-btn danger';
    btnNext.style.display = '';
    adjustRow.style.display = 'flex';
  }

  document.getElementById('btnBack').disabled = state.currentSeg === 0;

  updateTotalClock();

  const now = Date.now();
  if (!updateUI._lastSidebar || now - updateUI._lastSidebar > 1000) {
    updateUI._lastSidebar = now;
    updateSidebar();
  }
}

function updateTotalClock() {
  const show = SHOWS[currentShow];
  if (!show) return;

  const totalTarget = show.segments.reduce((s, seg) => s + seg.target, 0);
  document.getElementById('target').textContent = formatTime(totalTarget);

  const elapsedEl = document.getElementById('elapsed');

  if (state.phase === 'idle') {
    elapsedEl.textContent = '00:00';
    elapsedEl.style.color = '';
    return;
  }

  const completedTime = state.segActuals.reduce((s, t) => s + t, 0);
  const currentTime = (state.phase === 'running' || state.phase === 'paused') ? state.segElapsed : 0;
  const totalTime = completedTime + currentTime;
  elapsedEl.textContent = formatTime(totalTime);
  elapsedEl.style.color = totalTime > totalTarget ? 'var(--red)' : '';
}

function updateSidebar() {
  const show = SHOWS[currentShow];
  if (!show) return;

  const sidebar = document.getElementById('sidebar');
  const adjusted = getAdjustedTargets();

  let html = '<div class="sidebar-title">Segments</div>';

  // Drift summary banner
  if (state.phase !== 'idle' && state.phase !== 'complete') {
    const totalOriginal = show.segments.reduce((s, seg) => s + seg.target, 0);
    const timeUsed = state.segActuals.reduce((s, t) => s + t, 0) + state.segElapsed;
    const budgetUsed = show.segments.slice(0, state.segActuals.length + 1).reduce((s, seg) => s + seg.target, 0);
    const drift = Math.round(timeUsed - budgetUsed);
    if (Math.abs(drift) > 2) {
      const cls = drift > 0 ? 'drift-over' : 'drift-under';
      const label = drift > 0 ? `${formatTime(drift)} over pace` : `${formatTime(Math.abs(drift))} ahead`;
      html += `<div class="drift-banner ${cls}">${label} \u2014 adjusting upcoming targets</div>`;
    }
  }

  show.segments.forEach((seg, i) => {
    const isCompleted = i < state.segActuals.length;
    const isActive = i === state.currentSeg && state.phase !== 'idle' && state.phase !== 'complete';
    const isUpcoming = !isCompleted && !isActive;
    const isFinal = i === show.segments.length - 1;

    let cardClass = 'seg-card';
    if (isCompleted) cardClass += ' completed editable';
    else if (isActive) cardClass += ' active';
    else cardClass += ' upcoming';

    // Make completed segments clickable for editing
    const onclick = isCompleted ? ` onclick="openEditModal(${i})"` : '';

    let timeDisplay = '';
    let detail = '';

    if (isCompleted) {
      const actual = state.segActuals[i];
      const drift = actual - seg.target;
      timeDisplay = formatTime(actual);
      if (drift > 1) {
        detail = `<span class="drift-over">+${formatTime(drift)} over</span> &middot; tap to edit`;
      } else if (drift < -1) {
        detail = `<span class="drift-under">${formatTime(Math.abs(drift))} under</span> &middot; tap to edit`;
      } else {
        detail = 'On time &middot; tap to edit';
      }
    } else if (isActive) {
      timeDisplay = formatTime(Math.max(0, adjusted[i] - state.segElapsed));
      const remaining = adjusted[i] - state.segElapsed;
      const isAdj = Math.abs(adjusted[i] - seg.target) > 1;
      if (remaining < 0) {
        detail = `<span class="drift-over">OVER ${formatTime(Math.abs(remaining))}</span>`;
      } else if (remaining < 30) {
        detail = '<span class="adjusted">Wrapping up</span>';
      } else if (isAdj) {
        const diff = seg.target - adjusted[i];
        detail = `Target: ${formatTime(adjusted[i])} <span class="adjusted">(${diff > 0 ? 'saving' : 'gaining'} ${formatTime(Math.abs(diff))})</span>`;
      } else {
        detail = `Target: ${formatTime(seg.target)}`;
      }
    } else {
      timeDisplay = formatTime(adjusted[i]);
      if (Math.abs(adjusted[i] - seg.target) > 1) {
        const diff = seg.target - adjusted[i];
        detail = diff > 0
          ? `<span class="adjusted">${formatTime(adjusted[i])} \u2190 saving ${formatTime(diff)}</span>`
          : `<span class="drift-under">${formatTime(adjusted[i])} \u2190 gaining ${formatTime(Math.abs(diff))}</span>`;
      } else {
        detail = isFinal ? 'MUST HIT \u2014 ends the show' : 'Original';
      }
    }

    html += `
      <div class="${cardClass}"${onclick}>
        <div class="seg-card-header">
          <span class="seg-name">${seg.name}${isFinal ? ' (FINAL)' : ''}</span>
          <span class="seg-time">${timeDisplay}</span>
        </div>
        <div class="seg-detail">${detail}</div>
      </div>
    `;
  });

  // Intro card
  const totalDrift = state.segActuals.reduce((s, t, i) => s + (t - show.segments[i].target), 0);
  const introNeeded = show.introTarget - totalDrift;

  html += `
    <div class="seg-card intro-card">
      <div class="seg-card-header">
        <span class="seg-name">Intro (filmed last)</span>
        <span class="seg-time">${state.phase === 'complete' ? formatTime(Math.max(0, introNeeded)) : formatTime(show.introTarget)}</span>
      </div>
      <div class="seg-detail">${state.phase === 'complete'
        ? (totalDrift > 0 ? '<span class="adjusted">Shortened to compensate</span>' : totalDrift < 0 ? '<span class="drift-under">Extended \u2014 extra time</span>' : 'Standard')
        : 'Recorded after all segments'}</div>
    </div>
  `;

  sidebar.innerHTML = html;
}

// ===== HELPERS =====
function formatTime(totalSeconds) {
  const abs = Math.abs(totalSeconds);
  const m = Math.floor(abs / 60);
  const s = Math.floor(abs % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

// ===== KEYBOARD SHORTCUTS =====
document.addEventListener('keydown', (e) => {
  // Don't capture keys when editing a time
  if (document.getElementById('editOverlay').classList.contains('visible')) {
    if (e.code === 'Escape') closeEditModal();
    if (e.code === 'Enter') saveEditModal();
    return;
  }
  if (document.getElementById('confirmOverlay').classList.contains('visible')) {
    if (e.code === 'Escape') closeConfirm();
    return;
  }
  if (e.code === 'Space') { e.preventDefault(); toggleStartPause(); }
  if (e.code === 'ArrowRight') { e.preventDefault(); nextSegment(); }
  if (e.code === 'ArrowLeft') { e.preventDefault(); prevSegment(); }
  if (e.code === 'KeyR' && e.shiftKey) { e.preventDefault(); confirmReset(); }
});

// ===== INTRO TIMER =====
let introTimerInterval = null;
let introStartTime = null;
let introTargetSec = 10;

function startIntroTimer() {
  const show = SHOWS[currentShow];
  const totalActualSegments = state.segActuals.reduce((s, t) => s + t, 0);
  const drift = totalActualSegments - show.segments.reduce((s, seg) => s + seg.target, 0);
  introTargetSec = Math.max(1, show.introTarget - drift);

  document.getElementById('introTime').style.display = 'none';
  document.getElementById('introTimerLive').style.display = '';
  document.getElementById('btnIntroStart').textContent = 'Stop Intro';
  document.getElementById('btnIntroStart').setAttribute('onclick', 'stopIntroTimer()');
  document.getElementById('btnIntroStart').className = 'ctrl-btn primary pause';

  introStartTime = Date.now();
  introTimerInterval = setInterval(tickIntro, 100);
}

function tickIntro() {
  const elapsed = (Date.now() - introStartTime) / 1000;
  const remaining = introTargetSec - elapsed;
  const cd = document.getElementById('introCountdown');
  const sub = document.getElementById('introCountdownSub');

  if (remaining >= 0) {
    cd.textContent = formatTime(remaining);
    if (remaining <= 3) {
      cd.style.color = 'var(--yellow)';
      sub.textContent = 'Wrapping up...';
      sub.style.color = 'var(--yellow)';
    } else {
      cd.style.color = 'var(--green)';
      sub.textContent = `${formatTime(introTargetSec)} target`;
      sub.style.color = 'var(--text-dim)';
    }
  } else {
    cd.textContent = '-' + formatTime(Math.abs(remaining));
    cd.style.color = 'var(--red)';
    sub.textContent = `OVER by ${formatTime(Math.abs(remaining))}`;
    sub.style.color = 'var(--red)';
  }
}

function stopIntroTimer() {
  if (introTimerInterval) { clearInterval(introTimerInterval); introTimerInterval = null; }
  const elapsed = (Date.now() - introStartTime) / 1000;
  const cd = document.getElementById('introCountdown');
  const sub = document.getElementById('introCountdownSub');

  cd.textContent = formatTime(elapsed);
  cd.style.color = 'var(--text)';
  sub.textContent = `Intro recorded: ${formatTime(elapsed)} (target was ${formatTime(introTargetSec)})`;
  sub.style.color = 'var(--text-dim)';

  document.getElementById('btnIntroStart').textContent = 'Redo Intro';
  document.getElementById('btnIntroStart').setAttribute('onclick', 'startIntroTimer()');
  document.getElementById('btnIntroStart').className = 'ctrl-btn primary';
}

// ===== PREVENT ACCIDENTAL CLOSE =====
window.addEventListener('beforeunload', (e) => {
  if (state.phase !== 'idle') {
    e.preventDefault();
    e.returnValue = '';
  }
});

// ===== STARTUP =====
(function startup() {
  const restored = loadState();
  if (restored && state.phase !== 'idle') {
    // Restore UI to match saved state
    init();
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('activeTimer').style.display = '';
    document.querySelectorAll('.show-btn').forEach(b => b.style.pointerEvents = 'none');

    if (state.phase === 'running') {
      requestWakeLock();
      startTimer();
    } else if (state.phase === 'paused') {
      startBlink();
    } else if (state.phase === 'complete') {
      completeShow();
    }
    updateUI();
    updateSidebar();
  } else {
    init();
  }
})();
</script>
</body>
</html>
